{"name":"AppAuth for Android","tagline":"","body":"AppAuth for Android is a client SDK for communicating with [OAuth 2.0]\r\n(https://tools.ietf.org/html/rfc6749) and [OpenID Connect]\r\n(http://openid.net/specs/openid-connect-core-1_0.html) providers. It strives to\r\ndirectly map the requests and responses of those specifications, while following\r\nthe idiomatic style of the implementation language. In addition to mapping the\r\nraw protocol flows, convenience methods are available to assist with common\r\ntasks like performing an action with fresh tokens.\r\n\r\nThe library follows the best practices set out in [OAuth 2.0 for Native Apps]\r\n(https://tools.ietf.org/html/draft-ietf-oauth-native-apps)\r\nincluding using\r\n[Custom Tabs](http://developer.android.com/tools/support-library/features.html#custom-tabs)\r\nfor the auth request. For this reason,\r\n`WebView` is explicitly *not* supported due to usability and security reasons.\r\n\r\nThe library also supports the [PKCE](https://tools.ietf.org/html/rfc7636)\r\nextension to OAuth which was created to secure authorization codes in public\r\nclients when custom URI scheme redirects are used. The library is friendly to\r\nother extensions (standard or otherwise) with the ability to handle additional\r\nparameters in all protocol requests and responses.\r\n\r\n## Specification\r\n\r\n### Supported Android Versions\r\n\r\nAppAuth supports Android API 16 (Jellybean) and above.\r\n\r\nWhen a Custom Tabs implementation is provided by a browser on the device (for\r\nexample by\r\n[Chrome](https://developer.chrome.com/multidevice/android/customtabs)), Custom\r\nTabs are used for authorization requests. Otherwise, the default browser is used\r\nas a fallback.\r\n\r\n### Authorization Server Support\r\n\r\nBoth Custom URI Schemes (all supported versions of Android) and App Links\r\n(API 23+) can be used with the library.\r\n\r\nIn general, AppAuth can work with any Authorization Server (AS) that supports\r\n[native apps](https://tools.ietf.org/html/draft-ietf-oauth-native-apps),\r\neither through custom URI scheme redirects, or App Links.\r\nAS's that assume all clients are web-based or require clients to maintain\r\nconfidentiality of the client secrets may not work well.\r\n\r\n## Building the Project\r\n\r\n### Prerequisites\r\n\r\nThe project requires the Android SDK for API level 23 (Marshmallow) to build,\r\nthough the produced binaries only require API level 16 (Jellybean) to be\r\nused.\r\n\r\n### Configure the Demo App\r\n\r\nFollow the instructions in [app/README.md](app/README.md) to configure the\r\ndemo app with your own OAuth client (you need to update 3 configuration points\r\nwith your client info to try the demo).\r\n\r\n### Building from the Command line\r\n\r\nAppAuth for Android uses Gradle as its build system. In order to build\r\nthe library and app binaries, run `./gradlew assemble`.\r\nThe library AAR files are output to `library/build/outputs/aar`, while the\r\ndemo app is output to `app/build/outputs/apk`.\r\nIn order to run the tests and code analysis, run `./gradlew check`.\r\n\r\nThe build script attempts\r\nto guess the location of your SDK by looking at the values of $ANDROID_SDK_HOME\r\nand $ANDROID_HOME. If neither of these are defined or are not the SDK you\r\nwish to use, you must create a `local.properties` file in the project root.\r\nThis file must define a property `sdk.dir` that points to your SDK root\r\ndirectory. For example:\r\n\r\n    sdk.dir=/path/to/android-sdk\r\n\r\n### Building from Android Studio\r\n\r\nIn AndroidStudio, File -> New -> Import project. Select the root folder\r\n(the one with the `build.gradle` file).\r\n\r\nIf you get an error like:\r\n`Error:Could not find com.android.support:customtabs:23.2.0.` then be sure you\r\nhave installed the Android Support Library from the Android SDK Manager.\r\nFollow the Android Studio prompts to resolve the dependencies automatically.\r\n\r\n## Auth Flow\r\n\r\nAppAuth supports both manual interaction with the Authorization Server\r\nwhere you need to perform your own token exchanges, as well as convenience\r\nmethods that perform some of this logic for you. This example\r\nperforms a manual exchange, and stores the result as an `AuthState` object.\r\n\r\n### Tracking authorization state\r\n\r\n`AuthState` is a class that keeps track of the authorization and token\r\nrequests and responses, and provides a convenience method to call an API with\r\nfresh tokens. This is the only object that you need to serialize to retain the\r\nauthorization state of the session. Typically, one would do this by storing\r\nthe authorization state in SharedPreferences or some other persistent store\r\nprivate to the app:\r\n\r\n```java\r\n@NonNull public AuthState readAuthState() {\r\n  SharedPreferences authPrefs = getSharedPreferences(\"auth\", MODE_PRIVATE);\r\n  String stateJson = authPrefs.getString(\"stateJson\");\r\n  AuthState state;\r\n  if (stateStr != null) {\r\n    return AuthState.fromJsonString(stateJson);\r\n  } else {\r\n    return new AuthState();\r\n  }\r\n}\r\n\r\npublic void writeAuthState(@NonNull AuthState state) {\r\n  SharedPreferences authPrefs = getSharedPreferences(\"auth\", MODE_PRIVATE);\r\n  authPrefs.edit()\r\n      .putString(\"stateJson\", state.toJsonString())\r\n      .apply();\r\n}\r\n```\r\n\r\n### Configuration\r\n\r\nYou can configure AppAuth by specifying the endpoints directly:\r\n\r\n```java\r\nAuthorizationServiceConfiguration config =\r\n        new AuthorizationServiceConfiguration(name, mAuthEndpoint, mTokenEndpoint);\r\n\r\n// perform the auth request...\r\n```\r\n\r\nOr through discovery:\r\n\r\n```java\r\nUri issuerUri = Uri.parse(\"https://accounts.google.com\");\r\nAuthorizationServiceConfiguration config =\r\n    AuthorizationServiceConfiguration.fetchFromIssuer(\r\n        issuerUri,\r\n        new RetrieveConfigurationCallback() {\r\n          @Override public void onFetchConfigurationCompleted(\r\n              @Nullable AuthorizationServiceConfiguration serviceConfiguration,\r\n              @Nullable AuthorizationException ex) {\r\n            if (ex != null) {\r\n                Log.w(TAG, \"Failed to retrieve configuration for \" + idp.name, ex);\r\n            } else {\r\n                // service configuration retrieved, proceed to authorization...\r\n            }\r\n          }\r\n      });\r\n```\r\n\r\n### Authorizing\r\n\r\nAfter configuring or retrieving an authorization service configuration,\r\nan authorization request can be constructed for dispatch\r\n\r\n```java\r\nAuthorizationRequest req = new AuthorizationRequest.Builder(\r\n    config,\r\n    clientId,\r\n    AuthorizationRequest.RESPONSE_TYPE_CODE,\r\n    redirectUri);\r\n```\r\n\r\nRequests are dispatched with the help of `AuthorizationService`. As this\r\nwill open a custom tab or browser instance to fulfill this request, the\r\nresponse is delivered via an intent to an activity of your choosing:\r\n\r\n```java\r\nAuthorizationService service = new AuthorizationService(context);\r\nservice.performAuthorizationRequest(\r\n    req,\r\n    new Intent(context, MyAuthResultHandlerActivity.class));\r\n```\r\n\r\n### Handling the Redirect\r\n\r\nThe response is delivered to the specified handler, and can be extracted\r\nfrom the intent data:\r\n\r\n```java\r\npublic void onCreate(Bundle b) {\r\n  // ...\r\n  AuthorizationResponse resp = AuthorizationResponse.fromIntent(getIntent());\r\n  AuthorizationException ex = AuthorizationException.fromIntent(getIntent());\r\n  if (resp != null) {\r\n    // authorization succeeded\r\n  } else {\r\n    // authorization failed, check ex for more details\r\n  }\r\n  // ...\r\n}\r\n```\r\n\r\nGiven the auth response, a token request can be created to exchange the\r\nauthorization code:\r\n\r\n```java\r\nservice.performTokenRequest(\r\n    resp.createTokenExchangeRequest(),\r\n    new AuthorizationService.TokenResponseCallback() {\r\n      @Override public void onTokenRequestCompleted(\r\n            TokenResponse resp, AuthorizationException ex) {\r\n          if (resp != null) {\r\n            // exchange succeeded\r\n          } else {\r\n            // authorization failed, check ex for more details\r\n          }\r\n        }\r\n    });\r\n```\r\n\r\n### Making API Calls\r\n\r\nWith an updated AuthState based on the token exchange, it is then possible to\r\nmake requests using guaranteed fresh tokens at any future point:\r\n\r\n```\r\nAuthState state = readAuthState();\r\nstate.performActionWithFreshTokens(service, new AuthStateAction() {\r\n  @Override public void execute(\r\n      String accessToken,\r\n      String idToken,\r\n      AuthorizationException ex) {\r\n    if (ex != null) {\r\n      // negotiation for fresh tokens failed, check ex for more details\r\n      return;\r\n    }\r\n\r\n    // use the access token to do something ...\r\n  }\r\n});\r\n```\r\n\r\n## API Documentation\r\n\r\nBrowse the [API documentation]\r\n(http://openid.github.io/AppAuth-Android/docs/latest/).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}